substitutions:
  device_name: open-air-mini
  friendly_name: Open AIR Mini

  sensor_interval: 10 # seconds
  external_control_output_reset_time_seconds: 60 # seconds
  panic_mode_control_output: 100.0 # %
  panic_mode_duration_seconds: 120 # seconds

  fan_setpoint_min: 15.0
  fan_setpoint_max: 100.0

esphome:
  includes:
    open-air-mini.h

packages:
  common: !include common.yaml
  humidity_pid: !include
    file: pid.yaml
    vars:
      name: humidity
      type: cool
      setpoint_def: 70
      setpoint_min: 0
      setpoint_max: 100
      setpoint_step: 1
      sensor: air_humidity
      friendly_name_base: "${friendly_name} Sensor 1 Humidity"
      kp_def: 0.05  # [0-1/%] = 1 / 20 => each % above setpoint is 5% control output
      ti_def: 120.0 # [s]       ki = kp / ti = 0.05 / 120 = 1/2400 => 2400 = 60 * 10 * 4 = 60 * 4 * 10, e.g. it takes 10min@error=-4% or 4min@error=10% to drain integral -1->0
      min_integral: -0.5 # Full integral without error (i.e. when crossing back to below setpoint) is 50% control output: 5min@error-4% or 2min@error-10% to drain integral.
      max_integral: 0.0
  co2_pid: !include
    file: pid.yaml
    vars:
      name: co2
      type: cool
      setpoint_def: 800
      setpoint_min: 0
      setpoint_max: 2000
      setpoint_step: 10
      sensor: air_Co2
      friendly_name_base: "${friendly_name} Sensor 1 CO2"
      kp_def: 1.6666e-3 # [0-1/ppm] = 1 / 600 => each 3 PPM above setpoint is 1% control output
      ti_def: 400       # [s]         ki = 1 / 600 / 400 = 1 / 240000 => 240000 = 60 * 20 * 200 = 60 * 10 * 400, e.g. it takes 20min@error=-200ppm or 10min@error=-400ppm to drain the integral -1->0
      min_integral: -0.5 # Full integral without error (i.e. when crossing back to below setpoint) is 50% control output: 10min@error=-200ppm or 5min@error=-400ppm to drain integral.
      max_integral: 0.0
  voc_pid: !include
    file: pid.yaml
    vars:
      name: voc
      type: cool
      setpoint_def: 200
      setpoint_min: 0
      setpoint_max: 500
      setpoint_step: 1
      sensor: air_VOC
      friendly_name_base: "${friendly_name} Sensor 1 VOC"
      kp_def: 5.0000e-3 # [0-1/index] = 1 / 200 => each 2 indices above setpoint is 1% control output
      ti_def: 150       # [s]           ki = 1 / 200 / 150 = 1 / 30000 => 30000 = 60 * 10 * 50 = 60 * 5 * 100, e.g. it takes 10min@error=-50index or 5min@error=-100index to drain the integral -1->0
      min_integral: -0.5 # Full integral without error (i.e. when crossing back to below setpoint) is 50% control output: 5min@error=-50index or 2.5min@error=-100index
      max_integral: 0.0
  nox_pid: !include
    file: pid.yaml
    vars:
      name: nox
      type: cool
      setpoint_def: 20
      setpoint_min: 0
      setpoint_max: 500
      setpoint_step: 1
      sensor: air_NOx
      friendly_name_base: "${friendly_name} Sensor 1 NOx"
      kp_def: 5.0000e-3 # [0-1/index] = 1 / 200 => each 2 indices above setpoint is 1% control output
      ti_def: 15        # [s]           ki = 1 / 200 / 15 = 1 / 3000 => 3000 = 60 * 10 * 5 = 60 * 5 * 10, e.g. it takes 10min@error=-5index or 5min@error=-10index to drain the integral -1->0
      min_integral: -0.5
      max_integral: 0.0
  external_control_reset: !include
    file: resetting_sensor.yaml
    vars:
      script_id: open_air_mini_external_control_reset_script
      sensor_id: open_air_mini_external_control_output_sensor
      additional_reset_action: "id(open_air_mini_external_control_output_number)->publish_state(reset_value);"
  panic_mode_reset: !include
    file: resetting_sensor.yaml
    vars:
      script_id: open_air_mini_panic_mode_reset_script
      sensor_id: open_air_mini_panic_mode_control_output_sensor
      # additional_reset_action: # not needed, there is no number/input that needs to be reset along with the sensor: It is only a button that enables panic mode or resets the timer if already enabled.

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:
  level: INFO

# From V1.4.0 The Sensor pins on the Open AIR Mini are swapped. Correct example is below:
#uart:
##UART For Sensor 2
# - rx_pin: GPIO13
#   tx_pin: GPIO12
#   baud_rate: 9600
#   id: uart_sensor_2
##UART For Sensor 1
# - rx_pin: GPIO25
#   tx_pin: GPIO26
#   baud_rate: 9600
#   id: uart_sensor_1

i2c:
##I2C For Sensor 2
#- id: i2c_sensor_2
#  sda: GPIO19
#  scl: GPIO18
#  scan: false
#  frequency: 400kHz
#I2C For Sensor 1
- id: i2c_sensor_1
  sda: GPIO16
  scl: GPIO4
  scan: false
  frequency: 400kHz

# Status led
status_led:
  pin:
    number: GPIO33

#PWM output for controlling the motor.
output:
  - platform: ledc
    pin:
      number: GPIO15
      ignore_strapping_warning: true
    inverted: true
    id: open_air_mini

fan:
  - platform: speed
    output: open_air_mini
    name: "${friendly_name} Fan"
    id: fan_motor
    internal: true

number:
  - platform: template
    name: "${friendly_name} External Control Output"
    id: open_air_mini_external_control_output_number
    min_value: 0.0
    max_value: 100.0
    step: 1.0
    optimistic: true
    initial_value: 0.0
    restore_value: true
    unit_of_measurement: "%"
    device_class: "power_factor"
    on_value:
        # Execute the reset script on value > 0.0 (which is the reset value). Else only set the sensor accordingly.
        # Otherwise the publish_state to the reset value triggers the reset timer again, resulting in much logging.
        - if:
            condition:
              lambda: return x > 0.0;
            then:
              - script.execute:
                  id: open_air_mini_external_control_reset_script
                  new_value: !lambda return x;
                  reset_value: 0.0
                  reset_time_ms: !lambda return ${external_control_output_reset_time_seconds} * 1000;

button:
  - platform: template
    icon: mdi:emoticon-poop
    name: "${friendly_name} Panic Mode"
    on_press:
      - script.execute:
          id: open_air_mini_panic_mode_reset_script
          new_value: ${panic_mode_control_output}
          reset_value: 0.0
          reset_time_ms: !lambda return ${panic_mode_duration_seconds} * 1000;

sensor: 
  - platform: pulse_counter
    pin: GPIO14
    unit_of_measurement: 'RPM'
    name: '${friendly_name} Fan RPM'
    id: open_air_mini_rpm
    update_interval: 10s
    total:
      unit_of_measurement: 'Rotations'
      name: '${friendly_name} Fan Rotations'
      state_class: total_increasing

  - platform: scd4x
    i2c_id: i2c_sensor_1
    co2:
      name: "${friendly_name} Sensor 1 CO2"
      id: air_Co2
      accuracy_decimals: 0
      filters:
        heartbeat: 1s
    temperature:
      name: "${friendly_name} Sensor 1 Temperature"
      id: air_temperature
      accuracy_decimals: 2
      filters:
        lambda: return correct_temperature(x, id(open_air_mini_rpm).state);
    humidity:
      name: "${friendly_name} Sensor 1 Humidity"
      id: air_humidity
      accuracy_decimals: 2
      filters:
        # Pass "raw_state" and "state" of the temperature: the "uncorrected" and "corrected" temperatures.
        lambda: return correct_humidity(x, id(air_temperature).raw_state, id(air_temperature).state, id(open_air_mini_rpm).state);
        heartbeat: 1s
    update_interval: "${sensor_interval}s"
    measurement_mode: periodic

  - platform: sgp4x
    i2c_id: i2c_sensor_1
    voc:
      name: "${friendly_name} Sensor 1 VOC Index "
      id: air_VOC
      filters:
        heartbeat: 1s
    nox:
      name: "${friendly_name} Sensor 1 NOx Index "
      id: air_NOx
      filters:
        heartbeat: 1s
    compensation:
      temperature_source: air_temperature #Make sure to match these if you change ID's.
      humidity_source: air_humidity       #Make sure to match these if you change ID's.
    update_interval: "${sensor_interval}s"

  - platform: template
    name: "${friendly_name} External Control Output Sensor"
    id: open_air_mini_external_control_output_sensor
    unit_of_measurement: "%"
    device_class: "power_factor"

  - platform: template
    name: "${friendly_name} Panic Mode Control Output Sensor"
    id: open_air_mini_panic_mode_control_output_sensor
    unit_of_measurement: "%"
    device_class: "power_factor"

  - platform: combination
    name: "${friendly_name} Maximum of Control Outputs"
    unit_of_measurement: "%"
    device_class: "power_factor"
    type: max
    sources:
      - source: humidity_pid_output_sensor
      - source: co2_pid_output_sensor
      - source: voc_pid_output_sensor
      - source: nox_pid_output_sensor
      - source: open_air_mini_external_control_output_sensor
      - source: open_air_mini_panic_mode_control_output_sensor
    on_value:
      then:
        - sensor.template.publish:
            id: open_air_mini_pwm
            state: !lambda return (x * ${fan_setpoint_max} + (100.0 - x) * ${fan_setpoint_min}) / 100.0;

  - platform: template
    id: open_air_mini_pwm
    name: "${friendly_name} Fan PWM Setpoint"
    unit_of_measurement: "%"
    device_class: "power_factor"
    update_interval: never
    on_value:
      then:
        - output.set_level:
            id: open_air_mini
            level: !lambda return x / 100.0;
